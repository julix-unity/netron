import { NODE_CATEGORIES } from './source/grapher.js';
import fs from 'fs';

const filePath = './source/sentis-kernel-metadata.js';

const categoriesMap = {
    Reshape: { category: NODE_CATEGORIES.Transform },
    Conv: { category: NODE_CATEGORIES.Layer },
    MaxPool: { category: NODE_CATEGORIES.Pool },
    Celu: { category: NODE_CATEGORIES.Activation },
    Elu: { category: NODE_CATEGORIES.Activation },
    Gelu: { category: NODE_CATEGORIES.Activation },
    GeluFast: { category: NODE_CATEGORIES.Activation },
    Erf: { category: NODE_CATEGORIES.Activation },
    Hardmax: { category: NODE_CATEGORIES.Activation },
    HardSigmoid: { category: NODE_CATEGORIES.Activation },
    HardSwish: { category: NODE_CATEGORIES.Activation },
    LeakyRelu: { category: NODE_CATEGORIES.Activation },
    PRelu: { category: NODE_CATEGORIES.Activation },
    Relu: { category: NODE_CATEGORIES.Activation },
    Relu6: { category: NODE_CATEGORIES.Activation },
    Selu: { category: NODE_CATEGORIES.Activation },
    Sigmoid: { category: NODE_CATEGORIES.Activation },
    Softplus: { category: NODE_CATEGORIES.Activation },
    Softsign: { category: NODE_CATEGORIES.Activation },
    Swish: { category: NODE_CATEGORIES.Activation },
    Tanh: { category: NODE_CATEGORIES.Activation },
    ThresholdedRelu: { category: NODE_CATEGORIES.Activation },
    LogSoftmax: { category: NODE_CATEGORIES.Activation },
    Softmax: { category: NODE_CATEGORIES.Activation },
    ConvTranspose: { category: NODE_CATEGORIES.Layer },
    Shape: { category: NODE_CATEGORIES.Shape },
    Size: { category: NODE_CATEGORIES.Shape },
    ConstantOfShape: { category: NODE_CATEGORIES.Shape },
    OneHot: { category: NODE_CATEGORIES.Shape },
    Range: { category: NODE_CATEGORIES.Shape },
    ArgMax: { category: NODE_CATEGORIES.Shape },
    ArgMin: { category: NODE_CATEGORIES.Shape },
    Gather: { category: NODE_CATEGORIES.Transform },
    GatherElements: { category: NODE_CATEGORIES.Transform },
    GatherND: { category: NODE_CATEGORIES.Transform },
    NonZero: { category: NODE_CATEGORIES.Shape },
    ScatterElements: { category: NODE_CATEGORIES.Transform },
    ScatterND: { category: NODE_CATEGORIES.Transform },
    TopK: { category: NODE_CATEGORIES.Shape },
    And: { category: NODE_CATEGORIES.Logic },
    Compress: { category: NODE_CATEGORIES.Shape },
    Equal: { category: NODE_CATEGORIES.Logic },
    Greater: { category: NODE_CATEGORIES.Logic },
    GreaterOrEqual: { category: NODE_CATEGORIES.Logic },
    IsInf: { category: NODE_CATEGORIES.Logic },
    IsNaN: { category: NODE_CATEGORIES.Logic },
    Less: { category: NODE_CATEGORIES.Logic },
    LessOrEqual: { category: NODE_CATEGORIES.Logic },
    Not: { category: NODE_CATEGORIES.Logic },
    Or: { category: NODE_CATEGORIES.Logic },
    Xor: { category: NODE_CATEGORIES.Logic },
    Where: { category: NODE_CATEGORIES.Transform },
    Abs: { category: NODE_CATEGORIES.Math },
    Add: { category: NODE_CATEGORIES.Math },
    Ceil: { category: NODE_CATEGORIES.Math },
    Clip: { category: NODE_CATEGORIES.Math },
    CumSum: { category: NODE_CATEGORIES.Math },
    Dense: { category: NODE_CATEGORIES.Layer },
    DenseBatched: { category: NODE_CATEGORIES.Layer },
    Div: { category: NODE_CATEGORIES.Math },
    Einsum: { category: NODE_CATEGORIES.Math },
    Exp: { category: NODE_CATEGORIES.Math },
    Floor: { category: NODE_CATEGORIES.Math },
    Log: { category: NODE_CATEGORIES.Math },
    MatMul: { category: NODE_CATEGORIES.Layer },
    MatMul2D: { category: NODE_CATEGORIES.Layer },
    Max: { category: NODE_CATEGORIES.Math },
    Min: { category: NODE_CATEGORIES.Math },
    Mod: { category: NODE_CATEGORIES.Math },
    Mul: { category: NODE_CATEGORIES.Math },
    Neg: { category: NODE_CATEGORIES.Math },
    Pow: { category: NODE_CATEGORIES.Math },
    Reciprocal: { category: NODE_CATEGORIES.Math },
    Round: { category: NODE_CATEGORIES.Math },
    ScalarMad: { category: NODE_CATEGORIES.Math },
    Shrink: { category: NODE_CATEGORIES.Math },
    Sign: { category: NODE_CATEGORIES.Math },
    Sqrt: { category: NODE_CATEGORIES.Math },
    Square: { category: NODE_CATEGORIES.Math },
    Sub: { category: NODE_CATEGORIES.Math },
    ScaleBias: { category: NODE_CATEGORIES.Math },
    InstanceNormalization: { category: NODE_CATEGORIES.Normalization },
    LayerNormalization: { category: NODE_CATEGORIES.Normalization },
    BatchNormalization: { category: NODE_CATEGORIES.Normalization },
    LRN: { category: NODE_CATEGORIES.Normalization },
    NonMaxSuppression: { category: NODE_CATEGORIES.Shape },
    RoiAlign: { category: NODE_CATEGORIES.Shape },
    AveragePool: { category: NODE_CATEGORIES.Pool },
    GlobalAveragePool: { category: NODE_CATEGORIES.Pool },
    GlobalMaxPool: { category: NODE_CATEGORIES.Pool },
    RandomNormal: { category: NODE_CATEGORIES.Random },
    RandomNormalLike: { category: NODE_CATEGORIES.Random },
    RandomUniform: { category: NODE_CATEGORIES.Random },
    RandomUniformLike: { category: NODE_CATEGORIES.Random },
    Bernoulli: { category: NODE_CATEGORIES.Random },
    Multinomial: { category: NODE_CATEGORIES.Random },
    LSTM: { category: NODE_CATEGORIES.Layer },
    ReduceL1: { category: NODE_CATEGORIES.Reduction },
    ReduceL2: { category: NODE_CATEGORIES.Reduction },
    ReduceLogSum: { category: NODE_CATEGORIES.Math },
    ReduceLogSumExp: { category: NODE_CATEGORIES.Math },
    ReduceMax: { category: NODE_CATEGORIES.Math },
    ReduceMean: { category: NODE_CATEGORIES.Math },
    ReduceMin: { category: NODE_CATEGORIES.Math },
    ReduceProd: { category: NODE_CATEGORIES.Math },
    ReduceSum: { category: NODE_CATEGORIES.Math },
    ReduceSumSquare: { category: NODE_CATEGORIES.Math },
    Cast: { category: NODE_CATEGORIES.Transform },
    CastLike: { category: NODE_CATEGORIES.Transform },
    Concat: { category: NODE_CATEGORIES.Transform },
    DepthToSpace: { category: NODE_CATEGORIES.Transform },
    Expand: { category: NODE_CATEGORIES.Transform },
    Flatten: { category: NODE_CATEGORIES.Transform },
    GridSample: { category: NODE_CATEGORIES.Transform },
    Identity: { category: NODE_CATEGORIES.Shape },
    MoveDim: { category: NODE_CATEGORIES.Transform },
    Narrow: { category: NODE_CATEGORIES.Transform },
    Pad: { category: NODE_CATEGORIES.Transform },
    Resize: { category: NODE_CATEGORIES.Transform },
    Select: { category: NODE_CATEGORIES.Transform },
    Slice: { category: NODE_CATEGORIES.Transform },
    SliceSet: { category: NODE_CATEGORIES.Transform },
    SpaceToDepth: { category: NODE_CATEGORIES.Transform },
    Split: { category: NODE_CATEGORIES.Transform },
    Squeeze: { category: NODE_CATEGORIES.Transform },
    Tile: { category: NODE_CATEGORIES.Transform },
    Transpose: { category: NODE_CATEGORIES.Transform },
    Trilu: { category: NODE_CATEGORIES.Math },
    Unsqueeze: { category: NODE_CATEGORIES.Transform },
    Acos: { category: NODE_CATEGORIES.Math },
    Acosh: { category: NODE_CATEGORIES.Math },
    Asin: { category: NODE_CATEGORIES.Math },
    Asinh: { category: NODE_CATEGORIES.Math },
    Atan: { category: NODE_CATEGORIES.Math },
    Atanh: { category: NODE_CATEGORIES.Math },
    Cos: { category: NODE_CATEGORIES.Math },
    Cosh: { category: NODE_CATEGORIES.Math },
    Sin: { category: NODE_CATEGORIES.Math },
    Sinh: { category: NODE_CATEGORIES.Math },
    DequantizeUint8: { category: NODE_CATEGORIES.Quantization },
    Tan: { category: NODE_CATEGORIES.Math },
    Gemm: { category: NODE_CATEGORIES.Layer },
};

// Read the file as text
let fileContent = fs.readFileSync(filePath, 'utf8');

// Regex to match each Kernel entry
const kernelRegex = /(\s*)(\w+):\s*{\s*(inputs|outputs|args):/g;

// Add categories dynamically
fileContent = fileContent.replace(kernelRegex, (match, spaces, kernelName, firstKey) => {
    if (categoriesMap[kernelName]) {
        const categoryEntry = `${spaces}${kernelName}: {${spaces}    category: NODE_CATEGORIES.${categoriesMap[kernelName].category},`;
        return `${categoryEntry}${spaces}    ${firstKey}:`;
    }
    return match;
});

// Write back to the file
fs.writeFileSync(filePath, fileContent, 'utf8');
console.log('Categories added successfully!');
